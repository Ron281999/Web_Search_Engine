JVM Architecture 101: Get to Know Your Virtual Machine Skip to content Product Identify Prioritize Prevent Resolve Solutions For DevOps/SREs For Developers For QA Engineers For Executive Integrations Company About Us Our Customers Careers Resources Blog Try OverOps Product Product Why OverOps Identify Prevent Resolve Technology Architecture Security API The OverOps Difference Know when, where and WHY code breaks in real time Solutions By Role DevOps and SRE Developer QA Engineer Executives Integrations Log Analytics Performance Workflow Visualization See All Cost Of an error Find out how your application(s) error volume affects your bottom line. Company About Us Leadership Our Investors Careers Our Customers Events Press Blog “15 minutes after deploying OverOps, we found and fixed a critical error in our application” John McCann - VP, Digital Home Engineering, Comcast Read More Success Stories > Resources Whitepapers Case Studies Events Press eBooks Webinars Meet OverOps: Continuous Reliability Platform How OverOps Detects Sev1 Issues Before They Hit Production Handling Critical Errors in Microservices and Containers See All Whitepapers > How Empowered Deploys with Confidence to 430k Businesses How Intuit Engineers Meet Product Deadlines with Time to Spare How Comcast Ensures Application Reliability See All Case Studies > QCon Recap; How to Convince Your Manager to Address Technical Debt Jenkins World Recap; A Formula for Blocking SEV1s from Production Our Upcoming Events and Meetups >>> See Upcoming Events > OverOps Ensures Continuous Reliability in Kubernetes-Based Applications OverOps Helps Enterprises Shift Left with New CI/CD Integrations OverOps Reliability Dashboards Deepen Code-Level Visibility Read All Press Releases > The Complete Guide to Delivering Reliable Software in the Enterprise The Complete Guide to Building the Perfect DevOps Stack OverOps' Guide to Automated Root Cause Analysis Read Our eBooks > 2020 DevOps Stack: 10 Things Your SDLC Needs in the New Year Troubleshooting Kubernetes: The 7 Key Components You Need to Have Deploy with Confidence: The 3-Part Formula for Promoting Reliable Code Join Our Webinars > Blog Try OverOps JVM Architecture 101: Get to Know Your Virtual Machine By Tzofia Shiftan - April 18, 2018September 11, 2019 5 min read 0 Comments A beginner’s crash course in Java Virtual Machine (JVM) architecture and Java bytecode 101 Java applications are all around us, they’re on our phones, on our tablets, and on our computers. In many programming languages this means compiling the code multiple times in order for it to run on different OSes. For us as developers, maybe the coolest thing about Java is that it’s designed to be platform-independent (as the old saying goes, “Write once, run anywhere”), so we only need to write and compile our code once. How is this possible? Let’s dig into the Java Virtual Machine (JVM) to find out. Psst! Looking for a solution to help you identify and resolve application errors? OverOps provides code-level insights into all errors, exceptions and slowdowns at all stages of the software delivery lifecycle. The JVM Architecture It may sound surprising, but the JVM itself knows nothing about the Java programming language. Instead, it knows how to execute its own instruction set, called Java bytecode, which is organized in binary class files. Java code is compiled by the javac command into Java bytecode, which in turn gets translated into machine instructions by the JVM at runtime. Threads Java is designed to be concurrent, which means that different calculations can be performed at the same time by running several threads within the same process. When a new JVM process starts, a new thread (called the main thread) is created within the JVM. From this main thread, the code starts to run and other threads can be spawned. Real applications can have thousands of running threads that serve different purposes. Some serve user requests, others execute asynchronous backend tasks, etc. Stack and Frames Each Java thread is created along with a frame stack designed to hold method frames and to control method invocation and return. A method frame is used to store data and partial calculations of the method to which it belongs. When the method returns, its frame is discarded. Then, its return value is passed back to the invoker frame that can now use it to complete its own calculation. JVM Process Structure The JVM playground for executing a method is the method frame. The frame consists of two main parts: Local Variables Array – where the method’s parameters and local variables are stored Operand Stack – where the method’s computations are performed Frame structure Almost every bytecode command manipulates at least one of these two. Let’s see how. How It Works Let’s go over a simple example to understand how the different elements play together to run our program. Assume we have this simple program that calculates the value of 2+3 and prints the result: class SimpleExample { public static void main(String[] args) { int result = add(2,3); System.out.println(result); } public static int add(int a, int b) { return a+b; } } view raw SimpleExample.java hosted with ? by GitHub To compile this class we run javac SimpleExample.java, which results in the compiled file SimpleExample.class. We already know this is a binary file that contains bytecode. So how can we inspect the class bytecode? Using javap. javap is a command line tool that comes with the JDK and can disassemble class files. Calling javap -c -p prints out the disassembled bytecode (-c) of the class, including private (-p) members and methods: Compiled from "SimpleExample.java" class SimpleExample { SimpleExample(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."<init>":()V 4: return public static void main(java.lang.String[]); Code: 0: iconst_2 1: iconst_3 2: invokestatic #2 // Method add:(II)I 5: istore_1 6: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 9: iload_1 10: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 13: return public static int add(int, int); Code: 0: iload_0 1: iload_1 2: iadd 3: ireturn } view raw javap -c -p SimpleExample hosted with ? by GitHub Now what happens inside the JVM at runtime? java SimpleExample starts a new JVM process and the main thread is created. A new frame is created for the main method and pushed into the thread stack. The main method has two variables: args and result. Both reside in the local variable table. The first two bytecode commands of main, iconst_2, and iconst_3, load the constant values 2 and 3 (respectively) into the operand stack. The next command invokestatic invokes the static method add. Since this method expects two integers as arguments, invokestatic pops two elements from the operand stack and passes them to the new frame created by the JVM for add. main’s operand stack is empty at this point. In the add frame, these arguments are stored in the local variable array. The first two bytecode commands, iload_0 and iload_1 load the 0th and the 1st local variables into the stack. Next, iadd pops the top two elements from the operand stack, sums them up, and pushes the result back into the stack. Finally, ireturn pops the top element and passes it to the calling frame as the return value of the method, and the frame is discarded. main’s stack now holds the return value of add. istore_1 pops it and sets it as the value of the variable at index 1, which is result. getstatic pushes the static field java/lang/System.out of type java/io/PrintStream onto the stack. iload_1 pushes the variable at index 1, which is the value of result that now equals 5, onto the stack. So at this point the stack holds 2 values: the ‘out’ field and the value 5. Now invokevirtual is about to invoke the PrintStream.println method. It pops two elements from the stack: the first one is a reference to the object for which the println method is going to be invoked. The second element is an integer argument to be passed to the println method, that expects a single argument. This is where the main method prints the result of add. Finally, the return command finishes the method. The main frame is discarded, and the JVM process ends. Video Player https://blog.overops.com/wp-content/uploads/2018/04/jvm-101-1.mp4 00:00 00:00 00:48 Use Up/Down Arrow keys to increase or decrease volume. This is it. All in all, not too complex. “Write Once, Run Anywhere” So what makes Java platform-independent? It all lies in the bytecode. As we saw, any Java program compiles into standard Java bytecode. The JVM then translates it into the specific machine instructions at runtime. We no longer need to make sure our code is machine-compatible. Instead, our application can run on any device equipped with a JVM, and the JVM will do it for us. It’s the job of the JVM’s maintainers to provide different versions of JVMs to support different machines and operating systems. This architecture enables any Java program to run on any device having a JVM installed on it. And so the magic happens. Final Thoughts Java developers can write great applications without understanding how the JVM works. However, digging into the JVM architecture, learning its structure, and realizing how it interprets your code will help you become a better developer. It will also help you tackle really complex problem from time to time ? PS. If you’re looking for a deeper dive into the JVM and how all of this relates to Java exceptions, look no further! (It’s all right here.) Facebook Twitter LinkedIn HackerNews Email Tzofia Shiftan During her time at OverOps. Tzofia served as Head of Application Development. She is the founder of the R&D Leaders Group in Tel Aviv, and in her spare time, she likes to collect doodads from all over the world. Join the OverOps Community Sign Up Please visit our privacy policy for further details about our privacy practices. More from OverOps: [2018 Dev vs. Ops Survey] Why is DevOps Culture Creating Chaos in Enterprises? 1 Million Engineers Can’t Be Wrong: The Top Stories You Liked in 2018 The Top 100 Java Libraries in 2018 – Based on 277,975 Source Files Get our newest eBook: Java 9, 10 and BeyondDownload Up Next APM, Logs and BI: What You Don’t See… APM, Logs and BI: What You… APM, Logs and BI: What… Product Identify Prioritize Prevent Resolve Customers SaaS Trial Schedule Demo Roles Developer DevOps / SRE QA Engineer Executive Integrations Log Analytics Performance Workflow Visualization See All Company About Us Jobs Blog Resources eBooks Press Whitepapers Webinars Case Studies Events Follow Us By OverOps, Inc. 2020 Privacy hello@overops.com +1 415-767-1250 Thanks for sharing our post! Follow us for more: Send this to a friendYour emailRecipient emailYour message SendCancel Squash It Learn more about us! Free eBook Your Guide to Delivering Reliable Software Download Now